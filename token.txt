package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"log"
	"net/http"
	"sync"
	"sync/atomic"
	"time"
)

///////////////////////////////////////////////////////////////////////////
// TOKEN BUCKET (Thread-Safe, CAS Based)
///////////////////////////////////////////////////////////////////////////

const scale = 1_000_000 // fixed-point scaling for tokens

type TokenBucket struct {
	capacityScaled int64
	rateScaled     int64
	tokensScaled   int64
	lastRefill     int64
}

func NewTokenBucket(capacity float64, rate float64) *TokenBucket {
	now := time.Now().UnixNano()
	return &TokenBucket{
		capacityScaled: int64(capacity * float64(scale)),
		rateScaled:     int64(rate * float64(scale)),
		tokensScaled:   int64(capacity * float64(scale)),
		lastRefill:     now,
	}
}

func (tb *TokenBucket) refill() {
	for {
		last := atomic.LoadInt64(&tb.lastRefill)
		now := time.Now().UnixNano()
		if now <= last {
			return
		}
		elapsed := now - last
		toAdd := (tb.rateScaled * elapsed) / 1_000_000_000
		if !atomic.CompareAndSwapInt64(&tb.lastRefill, last, now) {
			continue
		}
		if toAdd <= 0 {
			return
		}
		for {
			cur := atomic.LoadInt64(&tb.tokensScaled)
			newVal := cur + toAdd
			if newVal > tb.capacityScaled {
				newVal = tb.capacityScaled
			}
			if atomic.CompareAndSwapInt64(&tb.tokensScaled, cur, newVal) {
				return
			}
		}
	}
}

func (tb *TokenBucket) Allow() bool {
	tb.refill()
	req := scale
	for {
		cur := atomic.LoadInt64(&tb.tokensScaled)
		if cur < req {
			return false
		}
		if atomic.CompareAndSwapInt64(&tb.tokensScaled, cur, cur-req) {
			return true
		}
	}
}

///////////////////////////////////////////////////////////////////////////
// METRICS
///////////////////////////////////////////////////////////////////////////

type Metrics struct {
	total    int64
	accepted int64
	rejected int64
}

func (m *Metrics) IncTotal()    { atomic.AddInt64(&m.total, 1) }
func (m *Metrics) IncAccepted() { atomic.AddInt64(&m.accepted, 1) }
func (m *Metrics) IncRejected() { atomic.AddInt64(&m.rejected, 1) }

///////////////////////////////////////////////////////////////////////////
// HTTP SERVER
///////////////////////////////////////////////////////////////////////////

func runServer(addr string, tb *TokenBucket, m *Metrics) {
	mux := http.NewServeMux()

	mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		m.IncTotal()
		if tb.Allow() {
			m.IncAccepted()
			w.WriteHeader(200)
			w.Write([]byte("OK\n"))
		} else {
			m.IncRejected()
			w.WriteHeader(429)
			w.Write([]byte("RATE_LIMIT_EXCEEDED\n"))
		}
	})

	mux.HandleFunc("/metrics", func(w http.ResponseWriter, r *http.Request) {
		resp := map[string]any{
			"total":    atomic.LoadInt64(&m.total),
			"accepted": atomic.LoadInt64(&m.accepted),
			"rejected": atomic.LoadInt64(&m.rejected),
			"tokens":   float64(atomic.LoadInt64(&tb.tokensScaled)) / float64(scale),
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(resp)
	})

	log.Printf("Server running on %s\n", addr)
	log.Fatal(http.ListenAndServe(addr, mux))
}

///////////////////////////////////////////////////////////////////////////
// LOAD TESTER
///////////////////////////////////////////////////////////////////////////

func runLoadTest(target string, workers int, duration time.Duration) {
	var total, ok, throttled int64
	stop := make(chan struct{})
	wg := sync.WaitGroup{}
	client := &http.Client{Timeout: 1 * time.Second}

	for i := 0; i < workers; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for {
				select {
				case <-stop:
					return
				default:
				}

				atomic.AddInt64(&total, 1)

				resp, err := client.Get(target)
				if err != nil {
					continue
				}
				io.Copy(io.Discard, resp.Body)
				resp.Body.Close()

				if resp.StatusCode == 200 {
					atomic.AddInt64(&ok, 1)
				} else if resp.StatusCode == 429 {
					atomic.AddInt64(&throttled, 1)
				}
			}
		}()
	}

	time.Sleep(duration)
	close(stop)
	wg.Wait()

	fmt.Println("Load Test Result:")
	fmt.Println("Total:", total)
	fmt.Println("OK:", ok)
	fmt.Println("Throttled:", throttled)
}

///////////////////////////////////////////////////////////////////////////
// MAIN
///////////////////////////////////////////////////////////////////////////

func main() {
	mode := flag.String("mode", "server", "server | load")
	addr := flag.String("addr", ":8080", "server address")
	capacity := flag.Float64("capacity", 10, "bucket capacity")
	rate := flag.Float64("rate", 5, "tokens per second")
	workers := flag.Int("workers", 50, "workers for load test")
	duration := flag.Duration("duration", 5*time.Second, "load test duration")
	target := flag.String("target", "http://localhost:8080/", "load test target URL")

	flag.Parse()

	tb := NewTokenBucket(*capacity, *rate)
	metrics := &Metrics{}

	if *mode == "server" {
		runServer(*addr, tb, metrics)
	} else if *mode == "load" {
		runLoadTest(*target, *workers, *duration)
	} else {
		log.Fatalf("unknown mode: %s", *mode)
	}
}
